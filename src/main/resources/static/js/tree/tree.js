// Generated by CoffeeScript 1.9.3
(function() {
  var Node, Tree, equal_angle, root;

  Node = (function() {
    function Node() {
      this.name = "";
      this.children = [];
    }

    Node.prototype.addChild = function(child) {
      if (child == null) {
        child = new Node;
      }
      this.children.push(child);
      child.father = this;
      return child;
    };

    Node.prototype.isLeaf = function() {
      return this.children.length === 0;
    };

    Node.prototype.isRoot = function() {
      return (this.father == null) || (this.father === null);
    };

    Node.prototype.string = function() {
      var c, s;
      s = "" + this.name + (this.length != null ? ":" + this.length : "");
      if (this.children.length > 0) {
        return "(" + (((function() {
          var j, len, ref, results;
          ref = this.children;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            results.push(c.string());
          }
          return results;
        }).call(this)).join(",")) + ")" + s;
      } else {
        return s;
      }
    };

    Node.prototype.show = function() {
      return console.log((this.string()) + ";");
    };

    Node.prototype.postToList = function(l) {
      var child, j, len, ref;
      if (l == null) {
        l = [];
      }
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        child.postToList(l);
      }
      l.push(this);
      return l;
    };

    return Node;

  })();

  Tree = function(s) {
    var flag, item, j, len, node, ref, ref1, ref2, token, tree;
    token = String(s).match(/[\(\),;:]|[^\(\),;:\s]+/g);
    if ((token == null) || token.length === 0) {
      throw "Invalid tree.";
    }
    tree = node = new Node;
    flag = false;
    for (j = 0, len = token.length; j < len; j++) {
      item = token[j];
      switch (item) {
        case "(":
          ref = [node.addChild(), false], node = ref[0], flag = ref[1];
          break;
        case ")":
          if (node.father == null) {
            throw "Invalid Tree: " + s;
          }
          ref1 = [node.father, false], node = ref1[0], flag = ref1[1];
          break;
        case ",":
          if (node.father == null) {
            throw "Invalid Tree: " + s;
          }
          ref2 = [node.father.addChild(), false], node = ref2[0], flag = ref2[1];
          break;
        case ":":
          flag = true;
          break;
        case ";":
          break;
        default:
          if (flag) {
            if (isNaN(node.length = parseFloat(item))) {
              throw "Invalid branch length: " + item;
            }
          } else {
            node.name = item;
          }
          flag = false;
      }
    }
    if (tree !== node) {
      throw "Invalid Tree: " + s;
    }
    return tree;
  };

  equal_angle = function(tree_string, length_scale, equal_length) {
    var angle, c, i, j, k, len, len1, len2, length, m, move_along, n, o, postlist, present_langle, ref, ref1, ref2, total_angle, tree;
    tree = Tree(tree_string);
    postlist = tree.postToList();
    for (i = j = 0, len = postlist.length; j < len; i = ++j) {
      n = postlist[i];
      if (n.isLeaf()) {
        n.numOfLeaves = 1;
      } else {
        n.numOfLeaves = 0;
        ref = n.children;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          c = ref[k];
          n.numOfLeaves += c.numOfLeaves;
        }
      }
    }
    move_along = function(loc, direction, length) {
      var x, y;
      x = loc[0], y = loc[1];
      x += Math.cos(direction) * length;
      y += Math.sin(direction) * length;
      return [x, y];
    };
    tree.angle = [0, Math.PI];
    tree.loc = [0, 0];
    for (i = m = ref1 = postlist.length - 1; ref1 <= 0 ? m <= 0 : m >= 0; i = ref1 <= 0 ? ++m : --m) {
      n = postlist[i];
      total_angle = (n.angle[1] - n.angle[0]) * 2;
      present_langle = n.angle[0];
      ref2 = n.children;
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        c = ref2[o];
        angle = total_angle * c.numOfLeaves / n.numOfLeaves;
        c.angle = [present_langle, present_langle + angle / 2];
        if (equal_length) {
          length = length_scale;
        } else {
          length = c.length * length_scale;
        }
        c.loc = move_along(n.loc, c.angle[1], length);
        present_langle = present_langle + angle;
      }
    }
    return tree;
  };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.equal_angle = equal_angle;

}).call(this);
